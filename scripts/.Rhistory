f0_range_z = (f0_range - f0_range_mean) / f0_range_sd,
F1_z = (F1 - F1_mean) / F1_sd,
F2_z = (F2 - F2_mean) / F2_sd,
F3_z = (F3 - F3_mean) / F3_sd
) %>%
# Deselect unneeded variables
select(-c(
dB_mean_sd, dB_mean_mean,
f0_mean_sd, f0_mean_mean,
f0_range_sd, f0_range_mean,
F1_sd, F1_mean,
F2_sd, F2_mean,
F3_sd, F3_mean
))
# Create tibble with means and sd per speaker and vowel for head_pos, lip_dist, and angle:
can %>%
na.omit() %>%
group_by(speaker, vowel) %>%
summarize_at(vars(head_pos, lip_dist, angle), list(mean = mean, sd = sd)) %>%
ungroup() %>%
{. ->> speakers_kin}
# Join tibble with means per speaker and vowel
can <- can %>%
left_join(speakers_kin, by = c("speaker", "vowel")) %>%
# Calculate z-scores
mutate(
head_pos_z = (head_pos - head_pos_mean) / head_pos_sd,
lip_dist_z = (lip_dist - lip_dist_mean) / lip_dist_sd,
angle_z = (angle - angle_mean) / angle_sd
) %>%
# deselect unneeded variables
select(-c(
head_pos_sd, head_pos_mean,
lip_dist_sd, lip_dist_mean,
angle_sd, angle_mean
))
can %>%
group_by(speaker) %>%
summarize_at(vars(angle), list(mean = mean, sd = sd))%>%
{. ->> speakers_angle} %>%
ungroup() %>%
print(n = Inf)
mean(speakers_angle$sd)
mean(speakers_angle$sd)
filter(speakers_angle, sd > 2.5)
can %>%
group_by(speaker) %>%
summarize_at(vars(angle), list(mean = mean, sd = sd))%>%
{. ->> speakers_angle} %>%
ungroup() %>%
print(n = Inf)
filter(speakers_angle, sd > 2.5)
filter(speakers_angle, sd < 2.5)
can <- left_join(can,
can %>%
group_by(speaker) %>%
summarize_at(vars(angle), list(mean_angle = mean, sd_angle = sd)) %>%
mutate(mover = ifelse(sd_angle < 2.5, 'no', 'yes')) %>%
ungroup())
can <- can %>%
mutate(angle_difference = angle - mean_angle) %>%
select(-c(sd_angle, mean_angle)) # deselect unneded variables
length(unique(can$speaker))
str(can)
can %>%
group_by(speaker) %>%
distinct(can_size, v_pos, h_pos, vowel) %>%
summarize(num_unique_realizations = n()) %>%
ungroup() %>%
print()
summary(can)
can %>%
group_by(speaker) %>%
summarize(num_unique_realizations = n_distinct(paste(can_size, v_pos, h_pos, vowel))) %>%
ungroup() %>%
print()
can %>%
group_by(speaker) %>%
summarize(num_unique_realizations = n_distinct(paste(can_size, v_pos, h_pos, vowel))) %>%
ungroup() %>%
print(n = 30)
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~sum(is.na(.))),
.groups = 'drop'
) %>%
print()
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~sum(is.na(.))),
.groups = 'drop'
) %>%
print(n = 30)
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~mean(is.na(.)) * 100, na.rm = TRUE),
.groups = 'drop'
) %>%
print()
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~mean(ifelse(is.na(.), 1, 0)) * 100),
.groups = 'drop'
) %>%
print()
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~mean(is.na(.)) * 100, na.rm = TRUE),
.groups = 'drop'
) %>%
print()
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~sum(is.na(.)) * 100, na.rm = TRUE),
.groups = 'drop'
) %>%
print()
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~ (sum(is.na(.)) / n()) * 100,
.groups = 'drop'
) %>%
print()
can %>%
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~ (sum(is.na(.)) / n()) * 100),
.groups = 'drop'
)
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~ (sum(is.na(.)) / n()) * 100, na.rm = T),
.groups = 'drop'
) %>%
print()
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~ (sum(is.na(.)) / n()) * 100),
.groups = 'drop'
) %>%
print()
columns_to_process <- c("dB_mean", "f0_mean", "f0_range", "F1", "F2", "F3", "head_pos", "lip_dist", "angle")
can %>%
group_by(speaker) %>%
summarize(
across(all_of(columns_to_process), ~ (mean(is.na(.)) * 100), na.rm = TRUE),
.groups = 'drop'
) %>%
print()
print(speakers_phon, n = 60)
print(speakers_kin, n = 60)
?normBark
colnames(can)
can <- mutate(can,
F1_bark = normBark(can$F1),
F2_bark = normBark(can$F2),
F3_bark = normBark(can$F3))
can_noNA <- can %>%
mutate(across(c(F1, F2, F3), ~ifelse(is.na(.), 9999, .)))
View(can_noNA)
can_noNA <- mutate(can_noNA,
F1_bark = normBark(F1),
F2_bark = normBark(F2),
F3_bark = normBark(F3))
can_noNA <- mutate(can_noNA,
across(c(F1_bark, F2_bark, F3_bark), ~ifelse(. == 9999, NA, .)))
View(can_noNA)
can_noNA <- mutate(can_noNA,
across(c(F1, F2, F3, F1_bark, F2_bark, F3_bark), ~ifelse(. == 9999, NA, .)))
View(can_noNA)
can_noNA <- mutate(can_noNA,
across(c(F1, F2, F3), ~ifelse(. == 9999, NA, .)),
across(c(F1_bark, F2_bark, F3_bark), ~ifelse(is.na(get(substring(cur_column(), 1, 2))), NA, .)))
View(can_noNA)
can <- can_noNA
rm(can_noNA)
str(can)
# Create a new column to represent the category (large or small) for each formant
can_try <- can %>%
mutate(formant_category = ifelse(can_size == "large", "large", "small"))
View(can_try)
rm(can_try)
# Pivot the data to create separate columns for each formant and category
can_formants_aside <- can %>%
pivot_wider(
id_cols = c(speaker, vowel, v_pos, h_pos),
names_from = can_size,
values_from = c(F1, F2, F3),
names_sep = "_"
) %>%
# Rename columns for clarity
rename(
F1_large = F1_large,
F1_small = F1_small,
F2_large = F2_large,
F2_small = F2_small,
F3_large = F3_large,
F3_small = F3_small
)
View(can_formants_aside)
# Pivot the data to create separate columns for each variable and category
can_formants_aside <- can %>%
pivot_wider(
id_cols = c(speaker, vowel, v_pos, h_pos),
names_from = can_size,
values_from = c(F1, F2, F3, lip_dist, F1_z, F2_z, F3_z, F1_bark, F2_bark, F3_bark),
names_sep = "_"
) %>%
# Rename columns for clarity
rename(
F1_large = F1_large,
F1_small = F1_small,
F2_large = F2_large,
F2_small = F2_small,
F3_large = F3_large,
F3_small = F3_small,
lip_dist_large = lip_dist_large,
lip_dist_small = lip_dist_small,
F1_z_large = F1_z_large,
F1_z_small = F1_z_small,
F2_z_large = F2_z_large,
F2_z_small = F2_z_small,
F3_z_large = F3_z_large,
F3_z_small = F3_z_small,
F1_bark_large = F1_bark_large,
F1_bark_small = F1_bark_small,
F2_bark_large = F2_bark_large,
F2_bark_small = F2_bark_small,
F3_bark_large = F3_bark_large,
F3_bark_small = F3_bark_small
)
# View the resulting dataframe
print(can_formants_aside)
can_formants_aside <- mutate(can_formants_aside,
dist_size_hz = sqrt((F1_large - F1_small)^2 + (F2_large - F2_small)^2),
dist_size_z = sqrt((F1_z_large - F1_z_small)^2 + (F2_z_large - F2_z_small)^2),
dist_size_bark = sqrt((F1_bark_large - F1_bark_small)^2 + (F2_bark_large - F2_bark_small)^2)
)
View(can_formants_aside)
summary(can)
can <- can %>%
mutate(
vowel_s = if_else(vowel == "I", -0.5, 0.5),
can_size_s = if_else(can_size == "small", -0.5, 0.5),
mover_s = if_else(mover == "no", -0.5, 0.5)
)
ggplot(can, aes(x = f0_mean)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black", alpha = 0.7) +
labs(title = "Distribution of f0_mean", x = "f0_mean") +
theme_minimal()
get_prior(formula = f0_mean ~ 1,
data = can,
family = lognormal())
exp(3)
log(3)
plogis(3)
exp(200)
lognormal(200)
log(200)
log(200)+3
exp(log(200)+3)
exp(log(200)+2)
exp(log(200)-2)
exp(log(200)-3)
# If we assume that the mean for *f*0 is 200
log(200)
exp(log(200)-1.5)
exp(log(200)+1.5)
# If we set the prior to normal(0,1), what would be the boundaries
exp(log(200)-0.5); exp(log(200)+0.5)
# If we set the prior to normal(0,2), what would be the boundaries
exp(log(200)-1); exp(log(200)+1)
# If we set the prior to normal(0,3), what would be the boundaries
exp(log(200)-1.5); exp(log(200)+1.5)
priors_intercept_only <- c(
prior('normal(0, 3)', class = 'Intercept')
)
mean_log <- log(200)
sd_values <- c(2, 3)
# Create a range of values for the x-axis
x_values <- seq(log(1), log(1000), length.out = 1000)
# Plot the density functions
plot(x_values, dlnorm(x_values, meanlog = mean_log, sdlog = sd_values[1]),
type = "l", col = "blue", lwd = 2, ylim = c(0, 0.1),
main = "Log-normal Distribution with Different Standard Deviations",
xlab = "log(Value)", ylab = "Density")
lines(x_values, dlnorm(x_values, meanlog = mean_log, sdlog = sd_values[2]),
col = "red", lwd = 2)
# Add vertical lines for the boundaries
abline(v = log(exp(mean_log) - sd_values[1]), col = "blue", lty = 2)
abline(v = log(exp(mean_log) + sd_values[1]), col = "blue", lty = 2)
abline(v = log(exp(mean_log) - sd_values[2]), col = "red", lty = 2)
abline(v = log(exp(mean_log) + sd_values[2]), col = "red", lty = 2)
# Set the intercept (mean of the log-normal distribution)
intercept <- log(200)
# Set different standard deviations
sd_values <- c(1, 2, 3)
# Create a data frame with x-axis values and densities for each standard deviation
df <- data.frame(x = seq(log(1), log(1000), length.out = 1000))
for (sd in sd_values) {
df[[paste0("density_sd", sd)]] <- dlnorm(df$x, meanlog = intercept, sdlog = sd)
}
# Convert the data frame to long format for ggplot2
df_long <- tidyr::gather(df, key = "SD", value = "Density", -x)
# Plot using ggplot2
ggplot(df_long, aes(x = exp(x), y = Density, color = SD)) +
geom_line(size = 1) +
scale_x_continuous(trans = 'log2', breaks = c(1, 10, 100, 1000)) +
labs(title = "Effect of Different Standard Deviations on Log-normal Distribution",
x = "Value", y = "Density", color = "Standard Deviation") +
theme_minimal()
# Set the intercept (mean of the log-normal distribution)
intercept <- log(200)
# Set different standard deviations
sd_values <- c(1, 2, 3)
# Create a data frame with x-axis values and densities for each standard deviation
df <- data.frame(x = seq(log(1), log(1000), length.out = 1000))
for (sd in sd_values) {
df[[paste0("density_sd", sd)]] <- dlnorm(df$x, meanlog = intercept, sdlog = sd)
}
# Convert the data frame to long format for ggplot2
df_long <- tidyr::gather(df, key = "SD", value = "Density", -x)
# Convert x values to exponential scale
df_long$exp_x <- exp(df_long$x)
# Plot using ggplot2 on the exponential scale
ggplot(df_long, aes(x = exp_x, y = Density, color = as.factor(SD))) +
geom_line(size = 1) +
scale_x_continuous(trans = 'log2', breaks = c(1, 10, 100, 1000)) +
labs(title = "Effect of Different Standard Deviations on Log-normal Distribution",
x = "Value", y = "Density", color = "Standard Deviation") +
theme_minimal()
# Create a sequence of values for the x-axis
x_values <- seq(log(1), log(1000), length.out = 1000)
# Plot the log-normal densities for different standard deviations on the exponential scale
plot(exp(x_values), dlnorm(x_values, meanlog = intercept, sdlog = 1), type = "l", col = "blue", xlab = "Value", ylab = "Density", log = "x", main = "Effect of Different Standard Deviations on Log-normal Distribution")
# Add lines for other standard deviations
lines(exp(x_values), dlnorm(x_values, meanlog = intercept, sdlog = 2), col = "red")
lines(exp(x_values), dlnorm(x_values, meanlog = intercept, sdlog = 3), col = "green")
# If we set the prior to normal(0,2), what would be the boundaries
exp(log(200)-1); exp(log(200)+1)
# Set the parameters for the normal distribution
mean_value <- 0
sd_value <- 2
# Create a sequence of values for the x-axis
x_values <- seq(mean_value - 4 * sd_value, mean_value + 4 * sd_value, length.out = 1000)
# Plot the normal density curve
plot(x_values, dnorm(x_values, mean = mean_value, sd = sd_value), type = "l", col = "blue", xlab = "Value", ylab = "Density", main = "Normal(0,2) Distribution")
# Add lines for better visualization
abline(v = mean_value, col = "red", lty = 2)  # Mean line
abline(v = mean_value - sd_value, col = "green", lty = 2)  # Lower bound line
abline(v = mean_value + sd_value, col = "green", lty = 2)  # Upper bound line
# Set the parameters for the normal distribution
mean_value <- 0
sd_value <- 2
# Compute the boundaries on the exponential scale
exp_lower_bound <- exp(mean_value - sd_value)
exp_upper_bound <- exp(mean_value + sd_value)
# Create a sequence of values for the x-axis
x_values <- seq(log(exp_lower_bound), log(exp_upper_bound), length.out = 1000)
# Plot the normal density curve on the log scale
plot(x_values, dnorm(x_values, mean = mean_value, sd = sd_value), type = "l", col = "blue", xlab = "Value (log scale)", ylab = "Density", main = "Normal(0,2) Distribution on Log Scale")
# Add lines for better visualization
abline(v = log(exp_lower_bound), col = "green", lty = 2)  # Lower bound line
abline(v = log(exp_upper_bound), col = "green", lty = 2)  # Upper bound line
# Convert x-axis labels back to exponential scale
axis(1, at = c(log(exp_lower_bound), log(exp_upper_bound)), labels = round(c(exp_lower_bound, exp_upper_bound), 2))
# If we set the prior to normal(0,2), what would be the boundaries
exp(log(200)-1); exp(log(200)+1)
# Set the parameters for the normal distribution
mean_value <- 0
sd_value <- 2
# Compute the boundaries on the exponential scale
exp_lower_bound <- exp(mean_value - sd_value)
exp_upper_bound <- exp(mean_value + sd_value)
# Plot the normal density curve on the log scale
curve(dnorm(x, mean = mean_value, sd = sd_value), from = log(1), to = log(1000), col = "blue", xlab = "Value (log scale)", ylab = "Density", main = "Normal(0,2) Distribution on Log Scale")
# Add lines for better visualization
abline(v = log(exp_lower_bound), col = "green", lty = 2)  # Lower bound line
abline(v = log(exp_upper_bound), col = "green", lty = 2)  # Upper bound line
# Convert x-axis labels back to exponential scale
axis(1, at = c(log(exp_lower_bound), log(exp_upper_bound)), labels = c(exp_lower_bound, exp_upper_bound))
# Set the parameters for the normal distribution
mean_value <- 0
sd_value <- 2
# Compute the boundaries on the log scale
log_lower_bound <- mean_value - sd_value
log_upper_bound <- mean_value + sd_value
# Values for the x-axis
x_values <- seq(log(1), log(1000), length.out = 1000)
# Compute the density for the lognormal distribution
density_values <- dlnorm(x_values, meanlog = 0, sdlog = 2)
# Plot the lognormal density curve on the log scale
plot(x_values, density_values, type = "l", col = "blue", xlab = "Value (log scale)", ylab = "Density", main = "Lognormal Distribution with Normal(0,2) Prior for Intercept")
# Add lines for better visualization
abline(v = log_lower_bound, col = "green", lty = 2)  # Lower bound line
abline(v = log_upper_bound, col = "green", lty = 2)  # Upper bound line
# Set the parameters for the normal prior
mean_prior <- 0
sd_prior <- 2
# Set the intercept value
intercept <- log(200)
# Generate a sequence of values for the intercept on the log scale
intercept_values <- seq(from = intercept - 3 * sd_prior, to = intercept + 3 * sd_prior, length.out = 1000)
# Calculate the corresponding density values using the normal distribution
density_values <- dnorm(intercept_values, mean = mean_prior, sd = sd_prior)
# Plot the prior distribution
plot(exp(intercept_values), density_values, type = "l", col = "blue", xlab = "Intercept", ylab = "Density", main = "Log-normal Model with Prior N(0,2) on Intercept")
# Add lines for better visualization
abline(v = exp(intercept), col = "red", lty = 2)  # Vertical line at the true intercept value
# Convert x-axis labels back to exponential scale
axis(1, at = exp(intercept), labels = exp(intercept))
# Set the parameters for the normal prior
mean_prior <- 0
sd_prior <- 2
# Set the intercept value
intercept <- log(200)
# Generate a sequence of values for the intercept on the log scale
intercept_values <- seq(from = intercept - 3 * sd_prior, to = intercept + 3 * sd_prior, length.out = 1000)
# Calculate the corresponding density values using the normal distribution
density_values <- dnorm(intercept_values, mean = mean_prior, sd = sd_prior)
# Plot the prior distribution with limited x-axis
plot(exp(intercept_values), density_values, type = "l", col = "blue", xlab = "Intercept", ylab = "Density", main = "Log-normal Model with Prior N(0,2) on Intercept", xlim = c(0, 1000))
# Add lines for better visualization
abline(v = exp(intercept), col = "red", lty = 2)  # Vertical line at the true intercept value
# Convert x-axis labels back to exponential scale
axis(1, at = exp(intercept), labels = exp(intercept))
summary(can)
get_prior(formula = f0_mean ~ 1 + vowel_s + can_size_s + head_pos + h_pos + v_pos + height +
(1 | speaker),
data = can,
family = lognormal())
exp(log(0)-0.5); exp(log(0)+0.5)
# Generate a sequence of values for the intercept
intercept_values_cauchy <- seq(from = -10, to = 10, length.out = 1000)
# Calculate the corresponding density values using the Cauchy distribution
density_values_cauchy <- dcauchy(intercept_values_cauchy, location = location, scale = scale)
# Set the parameters for the Cauchy prior
location <- 0
scale <- 2.5
# Plot the Cauchy prior distribution
curve(dcauchy(x, location = location, scale = scale), from = -10, to = 10, col = "green",
xlab = "Intercept", ylab = "Density", main = "Cauchy(0, 2.5) Prior")
# Add a vertical line at the median of the Cauchy distribution
abline(v = median(rt(1000, df = 1)), col = "blue", lty = 2)
get_prior(formula = f0_mean ~ 1 + vowel_s + can_size_s + head_pos + h_pos + v_pos + height +
(1 | speaker),
data = can,
family = lognormal())
priors_no_rSlopes <- c(
prior('normal(0, 3)', class = 'Intercept'),
prior('normal(0, 1)', class = b)
)
get_prior(formula = f0_mean ~ 1 + vowel_s + can_size_s + head_pos + h_pos + v_pos + height +
(1 + vowel_s + can_size_s + head_pos + h_pos + v_pos || speaker),
data = can,
family = lognormal())
get_prior(formula = f0_mean ~ 1 + vowel_s + can_size_s + head_pos + h_pos + v_pos + height +
(1 + vowel_s + can_size_s + head_pos + h_pos + v_pos || speaker),
data = can,
family = lognormal())
priors_max <- c(
prior('normal(0, 3)', class = 'Intercept'),
prior('normal(0, 1)', class = b)
)
mdl_intOnly <- brm(f0_mean ~ 1,
data = can,
priors = priors_intercept_only,
family = lognormal(),
backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 4000,
warmup = 2000,
seed = 997,
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_intOnly.rds"))
mdl_intOnly <- brm(f0_mean ~ 1,
data = can,
prior = priors_intercept_only,
family = lognormal(),
backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 4000,
warmup = 2000,
seed = 997,
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_intOnly.rds"))
summary(mdl_intOnly)
mdl_intOnly <- readRDS(paste0(models, "mdl_intOnly.rds"))
