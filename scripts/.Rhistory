pivot_wider(
id_cols = c(speaker, vowel, v_pos, h_pos),
names_from = can_size,
values_from = c(F1, F2, F3, lip_dist, F1_z, F2_z, F3_z, F1_bark, F2_bark, F3_bark),
names_sep = "_"
) %>%
# Rename columns for clarity
rename(
F1_large = F1_large,
F1_small = F1_small,
F2_large = F2_large,
F2_small = F2_small,
F3_large = F3_large,
F3_small = F3_small,
lip_dist_large = lip_dist_large,
lip_dist_small = lip_dist_small,
F1_z_large = F1_z_large,
F1_z_small = F1_z_small,
F2_z_large = F2_z_large,
F2_z_small = F2_z_small,
F3_z_large = F3_z_large,
F3_z_small = F3_z_small,
F1_bark_large = F1_bark_large,
F1_bark_small = F1_bark_small,
F2_bark_large = F2_bark_large,
F2_bark_small = F2_bark_small,
F3_bark_large = F3_bark_large,
F3_bark_small = F3_bark_small
)
# View the resulting dataframe
print(can_formants_aside)
# Chunk 30
can_formants_aside <- mutate(can_formants_aside,
dist_size_hz = sqrt((F1_large - F1_small)^2 + (F2_large - F2_small)^2),
dist_size_z = sqrt((F1_z_large - F1_z_small)^2 + (F2_z_large - F2_z_small)^2),
dist_size_bark = sqrt((F1_bark_large - F1_bark_small)^2 + (F2_bark_large - F2_bark_small)^2)
)
# Chunk 31
can <- can %>%
mutate(
vowel_s = if_else(vowel == "I", -0.5, 0.5),
can_size_s = if_else(can_size == "small", -0.5, 0.5),
mover_s = if_else(mover == "no", -0.5, 0.5)
)
# Chunk 32
length(unique(can$speaker))
# Chunk 33
can %>%
group_by(speaker) %>%
summarize(num_unique_realizations = n_distinct(paste(can_size, v_pos, h_pos, vowel))) %>%
ungroup() %>%
print(n = 30)
# Chunk 34
can %>%
group_by(speaker) %>%
summarize(
across(c(dB_mean, f0_mean, f0_range, F1, F2, F3, head_pos, lip_dist, angle),
~sum(is.na(.))),
.groups = 'drop'
) %>%
print(n = 30)
# Chunk 35
print(speakers_phon, n = 60)
# Chunk 36
print(speakers_kin, n = 60)
write.csv(can, paste0(data, "can.csv"), row.names = FALSE)
mdl_maxH1_headPos <- readRDS(paste0(models, "mdl_maxH1_headPos.rds"))
mdl_maxH1_vPos <- readRDS(paste0(models, "mdl_maxH1_vPos.rds"))
# Extract necessary posterior samples for head_pos and random effects for speaker
posterior_samples_headPos <- posterior_samples(mdl_maxH1_headPos, pars = c("b_head_pos", "r_speaker"))
# Process the random effects for each speaker
processed_samples <- as.data.frame(posterior_samples_headPos) %>%
gather(key = "term", value = "value", -b_head_pos) %>%
separate(term, into = c("effect", "speaker"), sep = "_", extra = "merge") %>%
filter(effect == "rspeaker") %>%
mutate(mu = b_head_pos + value) %>%
select(speaker, mu) %>%
mutate(speaker = as.numeric(str_replace_all(speaker, "\\[|\\]", "")))
# Clean up to save memory
rm(posterior_samples_headPos)
gc()
# Merge with 'can' dataset for the 'mover' variable
merged_data <- processed_samples %>%
left_join(can %>% select(speaker, mover) %>% distinct(), by = "speaker")
# Plot
p_hPos_mover <- ggplot(merged_data, aes(x = mu, y = reorder(as.factor(speaker), mu), fill = mover)) +
geom_halfeyeh(.width = .5, size = 2/3) +
scale_fill_manual(values = colorBlindBlack8) +
theme_minimal()
p_hPos_mover
# Create the plot using stat_halfeye
p_hPos_mover <- ggplot(merged_data, aes(x = mu, y = reorder(as.factor(speaker), mu), fill = mover)) +
stat_halfeye() +
scale_fill_manual(values = colorBlindBlack8) +
theme_minimal() +
labs(x = "Effect of Head Position", y = "Speaker", fill = "Mover")
p_hPos_mover
# Check the first few rows of processed_samples
head(processed_samples)
# Check the first few rows of merged_data
head(merged_data)
p_hPos_mover <- mdl_maxH1_headPos %>%
spread_draws(b_Intercept,
b_head_pos,
r_speaker[speaker,term]) %>%
filter(term == "head_pos") %>%
mutate(mu = b_head_pos + r_speaker) %>%
ungroup() %>%
mutate(speaker = str_replace_all(speaker, "[.]", " ")) %>%
mutate(speaker = as.double(speaker)) %>%
left_join(can %>% select(speaker, mover), by = "speaker") %>%
# plot
ggplot(aes(x = mu, y = reorder(speaker, mu), fill = mover)) +
geom_halfeyeh(.width = .5, size = 2/3) +  # You can set the fill color in geom_halfeyeh
scale_fill_manual(values = colorBlindBlack8) +  # Customize fill colors
theme_minimal()
p_hPos_mover
gc()
# Extracting posterior samples and converting to tidy format for specific predictors
post_maxH1_headPos <- mdl_maxH1_headPos %>%
gather_draws(b_vowel_s, b_can_size_s, b_head_pos, b_h_pos, b_height)
hypothesis(mdl_maxH1_headPos, c("vowel_s < 0", "head_pos > 0", "height < 0", "can_size_s < 0", "h_pos > 0"))
hypothesis(mdl_maxH1_headPos, "height < 0")
plot(mdl_maxH1_headPos, c("vowel_s < 0", "head_pos > 0", "height < 0", "can_size_s < 0", "h_pos > 0"))
plot(hypothesis(mdl_maxH1_headPos, c("vowel_s < 0", "head_pos > 0", "height < 0", "can_size_s < 0", "h_pos > 0")))
hypothesis(mdl_maxH1_vPos, c("vowel_s < 0", "v_pos < 0", "height < 0", "can_size_s < 0", "h_pos > 0"))
plot(hypothesis(mdl_maxH1_vPos, c("vowel_s < 0", "v_pos < 0", "height < 0", "can_size_s < 0", "h_pos > 0")))
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable")
postplot_maxH1_headPos
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Vowel", "Height", "Head pos.", "Horizontal pos.", "Can size")) +
postplot_maxH1_headPos
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Vowel", "Height", "Head pos.", "Horizontal pos.", "Can size"))
postplot_maxH1_headPos
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Head position", "Height", "Horizontal pos.", "Vowel"))
postplot_maxH1_headPos
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Head position", "Height", "Horizontal pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.15, 0.05))
postplot_maxH1_headPos
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Head position", "Height", "Horizontal pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.12, 0.02))
postplot_maxH1_headPos
# Extracting posterior samples
post_maxH1_headPos <- mdl_maxH1_headPos %>%
gather_draws(b_vowel_s, b_can_size_s, b_head_pos, b_h_pos, b_height)
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.5, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Head position", "Height", "Horizontal pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.12, 0.02))
postplot_maxH1_headPos
# Extracting posterior samples
post_maxH1_vPos <- mdl_maxH1_vPos %>%
gather_draws(b_vowel_s, b_can_size_s, b_v_pos, b_h_pos, b_height)
# Plotting intervals with densities
postplot_maxH1_vPos <-
ggplot(post_maxH1_vPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Height", "Horizontal pos.", "Vertical pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.12, 0.02))
postplot_maxH1_vPos
# Extracting posterior samples
post_maxH1_vPos <- mdl_maxH1_vPos %>%
gather_draws(b_vowel_s, b_can_size_s, b_v_pos, b_h_pos, b_height)
# Plotting intervals with densities
postplot_maxH1_vPos <-
ggplot(post_maxH1_vPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Height", "Horizontal pos.", "Vertical pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.13, 0.01))
postplot_maxH1_vPos
scatter_z_formant <- ggplot(can,
aes(y = F2_z,
x = F1_z,
color = vowel)) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1)  +
scale_color_manual(values=mycols) +
labs(x = "F1 (z-normalized)",
y = "F2 (z-normalized)",
color = "Vowel")
scatter_z_formant <- ggplot(can,
aes(y = F2_z,
x = F1_z,
color = vowel)) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1)  +
scale_color_manual(values = colorBlindBlack8) +
labs(x = "F1 (z-normalized)",
y = "F2 (z-normalized)",
color = "Vowel")
print(scatter_z_formant +
facet_wrap(~can_size) +
theme_bw() +
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)))
scatter_z_formant <- ggplot(can,
aes(y = F2,
x = F1,
color = vowel)) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1)  +
scale_color_manual(values = colorBlindBlack8) +
labs(x = "F1 (z-normalized)",
y = "F2 (z-normalized)",
color = "Vowel")
print(scatter_z_formant +
facet_wrap(~can_size) +
theme_bw() +
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)))
scatter_formant_v <- ggplot(can,
aes(y = F2,
x = F1,
color = vowel)) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1)  +
scale_color_manual(values = colorBlindBlack8) +
labs(x = "F1",
y = "F2",
color = "Vowel")
print(scatter_formant_v +
facet_wrap(~can_size) +
theme_bw() +
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)))
scatter_formant_size <- ggplot(can,
aes(y = F2,
x = F1,
color = can_size)) +
facet_wrap(~vowel) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1)  +
scale_color_manual(values = colorBlindBlack8) +
labs(y = "F2",
x = "F1",
color = "Can size") +
theme_bw() +
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
scatter_formant_size
# ggsave(plot = scatter_z_formant, filename = "size_vowel.pdf", width = 7, height = 4)
vowel_space <- with(can, plotVowels(F1, F2, vowel,
group = can_size,
plot.tokens = FALSE,
plot.means = TRUE,
pch.means = vowel,
cex.means = 2,
var.col.by = can_size,
var.sty.by = can_size,
ylim = c(2,-2),
xlim = c(2,-2),
ellipse.fill = T,
poly.line = T,
pretty = T,
col = mycols,
legend.kwd = "bottomleft",
cex.lab = 1.2,
cex.axis = 1
#main = "Z"
))
vowel_space <- with(can, plotVowels(F1, F2, vowel,
group = can_size,
plot.tokens = FALSE,
plot.means = TRUE,
pch.means = vowel,
cex.means = 2,
var.col.by = can_size,
var.sty.by = can_size,
ylim = c(2,-2),
xlim = c(2,-2),
ellipse.fill = T,
poly.line = T,
pretty = T,
col = colorBlindBlack8,
legend.kwd = "bottomleft",
cex.lab = 1.2,
cex.axis = 1
#main = "Z"
))
vowel_space <- with(can, plotVowels(F1, F2, vowel,
group = can_size,
plot.tokens = FALSE,
plot.means = TRUE,
pch.means = vowel,
cex.means = 2,
var.col.by = can_size,
var.sty.by = can_size,
ellipse.fill = T,
poly.line = T,
pretty = T,
col = colorBlindBlack8,
legend.kwd = "bottomleft",
cex.lab = 1.2,
cex.axis = 1
#main = "Z"
))
#ggsave(plot = vowel_space_Z, filename = "size-vowel-phonR.pdf", width = 7, height = 4)
vowel_space_bark <- with(can, plotVowels(F1_bark, F2_bark, vowel,
group = can_size,
plot.tokens = FALSE,
plot.means = TRUE,
pch.means = vowel,
cex.means = 1.5,
var.col.by = can_size,
var.sty.by = can_size,
#ylim = c(10,3),
#xlim = c(15,8),
ellipse.fill = T,
poly.line = T,
pretty = T,
legend.kwd = "bottomleft",
main = "Bark"))
# And then plot it:
size_vowel_v1 <- ggplot(formant_v1,
aes(y = F1,
x = F2,
color = can_size)) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1) +
scale_color_manual(values=colorBlindBlack8) +
labs(x = "F1",
y = "F2",
color = "Can size") +
facet_wrap(~vowel) +
theme_bw() +
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
# First, filter the data:
formant_v1 <- filter(can, vertical == '1')
# First, filter the data:
formant_v1 <- filter(can, v_pos == '1')
# And then plot it:
size_vowel_v1 <- ggplot(formant_v1,
aes(y = F1,
x = F2,
color = can_size)) +
geom_point(alpha = 0.2) +
stat_ellipse(segments = 51,
size = 1) +
scale_color_manual(values=colorBlindBlack8) +
labs(x = "F1",
y = "F2",
color = "Can size") +
facet_wrap(~vowel) +
theme_bw() +
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
size_vowel_v1
lip <- ggplot(can,
aes(y = lip_dist,
x = vowel,
fill = can_size)) +
geom_violin(position = position_dodge(1),
trim = FALSE,
alpha = 0.4) +
# adds median and quartile:
geom_boxplot(width = 0.1,
position = position_dodge((1)),
alpha = 0.6,
outlier.shape = NA, # Hides outliers.
notch = T, #  Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.
coef = 0) + # Length of the whiskers as multiple of IQR. Defaults to 1.5.
scale_fill_manual(values = colorBlindBlack8) +
labs(x = "Vowel",
y = "Lip opening",
fill = "Can size") +
theme_bw()+
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
lip
# ggsave(plot = lip, filename = "lip.pdf", width = 6, height = 4)
p_fDisp_vowel_size <- ggplot(can,
aes(y = f_disp,
x = vowel,
fill = can_size)) +
geom_violin(position = position_dodge(1),
trim = FALSE,
alpha = 0.4) +
# adds median and quartile:
geom_boxplot(width = 0.1,
position = position_dodge((1)),
alpha = 0.6,
outlier.shape = NA, # Hides outliers.
notch = T, #  Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.
coef = 0) + # Length of the whiskers as multiple of IQR. Defaults to 1.5.
scale_fill_manual(values = colorBlindBlack8) +
labs(x = "Vowel",
y = "Lip opening",
fill = "Can size") +
theme_bw()+
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
p_fDisp_vowel_size
colnames(can)
can <- can %>%
mutate(f_disp = ((F2 - F1) + (F3 - F2)) / 2)
p_fDisp_vowel_size <- ggplot(can,
aes(y = f_disp,
x = vowel,
fill = can_size)) +
geom_violin(position = position_dodge(1),
trim = FALSE,
alpha = 0.4) +
# adds median and quartile:
geom_boxplot(width = 0.1,
position = position_dodge((1)),
alpha = 0.6,
outlier.shape = NA, # Hides outliers.
notch = T, #  Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.
coef = 0) + # Length of the whiskers as multiple of IQR. Defaults to 1.5.
scale_fill_manual(values = colorBlindBlack8) +
labs(x = "Vowel",
y = "Lip opening",
fill = "Can size") +
theme_bw()+
theme(axis.text = element_text(size = 12),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
p_fDisp_vowel_size
# ggsave(plot = lip, filename = "lip.pdf", width = 6, height = 4)
