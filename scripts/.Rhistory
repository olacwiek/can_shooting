control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_maxH1_vPos.rds"))
# if we need to compress the model more
#saveRDS(mdl_maxH1_vPos, file = paste0(models, "mdl_maxH1_vPos.rds"), compress = "xz")
mdl_maxH1_vPos <- readRDS(paste0(models, "mdl_maxH1_vPos.rds"))
beepr::beep()
# Chunk 80
summary(mdl_maxH1_vPos)
# Chunk 81
plot(mdl_maxH1_vPos)
conditional_effects(mdl_maxH1_vPos, sample_prior = "only")
# Chunk 84
# run loo mdl
if (file.exists(paste0(models, "mdl_maxH1_vPos_loo.rds"))) {
mdl_maxH1_vPos_loo <- readRDS(paste0(models, "mdl_maxH1_vPos_loo.rds"))
} else {
mdl_maxH1_vPos_loo <- loo(mdl_maxH1_vPos, moment_match = TRUE)
saveRDS(mdl_maxH1_vPos_loo, paste0(models, "mdl_maxH1_vPos_loo.rds"))
}
# Chunk 85
mdl_maxH1_vPos_loo
# Chunk 86
if (file.exists(paste0(models, "mdl_maxH1_vPos_reloo.rds"))) {
mdl_maxH1_vPos_reloo <- readRDS(paste0(models, "mdl_maxH1_vPos_reloo.rds"))
} else {
mdl_maxH1_vPos_reloo <- reloo(mdl_maxH1_vPos_loo, mdl_maxH1_vPos, chains = 1)
saveRDS(mdl_maxH1_vPos_reloo, paste0(models, "mdl_maxH1_vPos_reloo.rds"))
}
mdl_maxH1_vPos_reloo
# Chunk 87
compH1_headPos <- loo_compare(mdl_noRandomH1_headPos_loo,mdl_maxH1_headPos_reloo)
compH1_headPos
# Chunk 88
compH1_vPos <- loo_compare(mdl_intOnlyH1_loo,mdl_noRandomH1_vPos_loo,mdl_maxH1_vPos_reloo)
compH1_vPos
# Chunk 89
summary(mdl_maxH1_headPos)
# Chunk 90
hypothesis(mdl_maxH1_headPos, "vowel_s < 0")
plot(hypothesis(mdl_maxH1_headPos, "vowel_s < 0"))
# Chunk 91
hypothesis(mdl_maxH1_headPos, "head_pos > 0")
plot(hypothesis(mdl_maxH1_headPos, "head_pos > 0"))
# Chunk 92
hypothesis(mdl_maxH1_headPos, "height < 0")
plot(hypothesis(mdl_maxH1_headPos, "height < 0"))
# Chunk 93
hypothesis(mdl_maxH1_headPos, "can_size_s < 0")
plot(hypothesis(mdl_maxH1_headPos, "can_size_s < 0"))
# Chunk 94
hypothesis(mdl_maxH1_headPos, "h_pos > 0")
plot(hypothesis(mdl_maxH1_headPos, "h_pos > 0"))
# Chunk 95
summary(can$head_pos) # the unit is centimeters
exp(fixef(mdl_maxH1_headPos))
exp(fixef(mdl_maxH1_headPos)[1,1]) # intercept in Hz
exp(fixef(mdl_maxH1_headPos)[4,1]) # estimate head_pos in Hz (positive)
exp(fixef(mdl_maxH1_headPos)[2,1]) # estimate vowel_s in Hz (negative)
# Chunk 96
hypothesis(mdl_maxH1_headPos, c("vowel_s < 0", "head_pos > 0", "height < 0", "can_size_s < 0", "h_pos > 0"))
plot(hypothesis(mdl_maxH1_headPos, c("vowel_s < 0", "head_pos > 0", "height < 0", "can_size_s < 0", "h_pos > 0")))
# Chunk 97
summary(mdl_maxH1_vPos)
# Chunk 98
hypothesis(mdl_maxH1_vPos, "vowel_s < 0")
plot(hypothesis(mdl_maxH1_vPos, "vowel_s < 0"))
# Chunk 99
hypothesis(mdl_maxH1_vPos, "v_pos < 0")
plot(hypothesis(mdl_maxH1_vPos, "v_pos < 0"))
# Chunk 100
hypothesis(mdl_maxH1_vPos, "height < 0")
plot(hypothesis(mdl_maxH1_vPos, "height < 0"))
# Chunk 101
hypothesis(mdl_maxH1_vPos, "can_size_s < 0")
plot(hypothesis(mdl_maxH1_vPos, "can_size_s < 0"))
# Chunk 102
hypothesis(mdl_maxH1_vPos, "h_pos > 0")
plot(hypothesis(mdl_maxH1_vPos, "h_pos > 0"))
# Chunk 103
summary(can$v_pos)
exp(fixef(mdl_maxH1_vPos))
exp(fixef(mdl_maxH1_vPos)[1,1]) # intercept in Hz
exp(fixef(mdl_maxH1_vPos)[5,1]) # estimate v_pos in Hz (positive)
exp(fixef(mdl_maxH1_vPos)[2,1]) # estimate vowel_s in Hz (negative)
# Chunk 104
hypothesis(mdl_maxH1_vPos, c("vowel_s < 0", "v_pos < 0", "height < 0", "can_size_s < 0", "h_pos > 0"))
plot(hypothesis(mdl_maxH1_vPos, c("vowel_s < 0", "v_pos < 0", "height < 0", "can_size_s < 0", "h_pos > 0")))
# Chunk 105
can %>%
group_by(speaker) %>%
summarize(head_range = max(head_pos, na.rm = TRUE) - min(head_pos, na.rm = TRUE)) %>%
ungroup() %>%
{. ->> head_range} %>%
print(n = 30)
# Chunk 106
# brmstools::forest(mdl_maxH1_headPos,
#                   grouping = "speaker",
#                   pars = "head_pos",
#                   digits = 0,
#                   sort = T)
# See new way:
# https://github.com/mvuorre/brmstools?tab=readme-ov-file#forest-plots
# Chunk 107
p_hPos_mover <- mdl_maxH1_headPos %>%
spread_draws(b_Intercept, b_head_pos, r_speaker[speaker,term]) %>%
filter(term == "head_pos") %>%
mutate(mu = b_head_pos + r_speaker) %>%
ungroup() %>%
mutate(speaker = str_replace_all(speaker, "[.]", " ")) %>%
mutate(speaker = as.double(speaker)) %>%
left_join(can %>% select(speaker, mover), by = "speaker") %>%
ggplot(aes(x = mu, y = reorder(speaker, mu), fill = mover)) +
geom_halfeyeh(.width = .5, size = 2/3, alpha = 0.5) +  # Adjusted alpha for fill color
scale_fill_manual(values = colorBlindBlack8) +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey") +  # Grey dashed line at 0
labs(x = "Posterior distribution (Head position)", y = "Speaker", fill = "Mover") +
theme_minimal()
p_hPos_mover
#ggsave(file = paste0(plots, "p_hPos_mover.svg"), plot = p_hPos_mover, width = 10, height = 8)
# this is very memory-consuming, so run this to kind of "reset"
gc()
# Chunk 108
ggplot(can, aes(x = head_pos, y = f0_mean, color = factor(vowel))) +
geom_point(alpha = 0.5) +
stat_smooth(method = "lm", se = TRUE) +
labs(color = "Vowel", x = "Head Position (cm)", y = "f0 Mean (Hz)") +
theme_minimal() +
scale_color_manual(values = colorBlindBlack8)
# Chunk 109
# Extracting posterior samples
post_maxH1_headPos <- mdl_maxH1_headPos %>%
gather_draws(b_vowel_s, b_can_size_s, b_head_pos, b_h_pos, b_height)
# Plotting intervals with densities
postplot_maxH1_headPos <-
ggplot(post_maxH1_headPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Head position", "Height", "Horizontal pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.12, 0.02))
postplot_maxH1_headPos
# Chunk 110
ggplot(can, aes(x = v_pos, y = f0_mean, color = factor(vowel))) +
geom_point(alpha = 0.5) +
stat_smooth(method = "lm", se = TRUE) +
labs(color = "Vowel", x = "Vertical Position", y = "f0 Mean (Hz)") +
theme_minimal() +
scale_color_manual(values = colorBlindBlack8)
# Chunk 111
# Extracting posterior samples
post_maxH1_vPos <- mdl_maxH1_vPos %>%
gather_draws(b_vowel_s, b_can_size_s, b_v_pos, b_h_pos, b_height)
# Plotting intervals with densities
postplot_maxH1_vPos <-
ggplot(post_maxH1_vPos,
aes(x = .value, y = .variable)) +
stat_halfeye(.width = 0.95, fill = colorBlindBlack8[2], alpha = 0.7, size = 2) +
geom_segment(x = 0, xend = 0, y = -Inf, yend = Inf,
linetype = "dashed", color = "grey", size = 1) +
theme_bw() +
labs(x = "Posterior density", y = "Variable") +
scale_y_discrete(labels = c("Can size", "Height", "Horizontal pos.", "Vertical pos.", "Vowel")) + # Must be in alphabetical order
scale_x_continuous(limits = c(-0.13, 0.01))
postplot_maxH1_vPos
# Chunk 112
formants_a_large <- can %>%
filter(vowel == "a") %>%
filter(.,can_size == 'large')
formants_a_small <- can %>%
filter(vowel == "a") %>%
filter(.,can_size == 'small')
formants_i_large <- can %>%
filter(vowel == "I") %>%
filter(.,can_size == 'large')
formants_i_small <- can %>%
filter(vowel == "I") %>%
filter(.,can_size == 'small')
# Chunk 113
area_a_large = ggplot(formants_a_large,
aes(y = F1,
x = F2)) +
geom_point() +
stat_ellipse(segments = 201) # Default is 51. We use a finer grid for more accurate area.
# Chunk 114
pb = ggplot_build(area_a_large)
el = pb$data[[2]][c("x", "y")]
# Chunk 115
ctr = MASS::cov.trob(el)$center  # Per @Roland's comment
# Chunk 116
dist2center <- sqrt(rowSums((t(t(el) - ctr))^2))
# Chunk 117
area_a_large <- pi*min(dist2center)*max(dist2center)
area_a_large
# Chunk 118
area_a_small = ggplot(formants_a_small,
aes(y = F1,
x = F2)) +
geom_point() +
stat_ellipse(segments = 201) # Default is 51. We use a finer grid for more accurate area.
# Chunk 119
pb = ggplot_build(area_a_small)
el = pb$data[[2]][c("x", "y")]
# Chunk 120
ctr = MASS::cov.trob(el)$center  # Per @Roland's comment
# Chunk 121
dist2center <- sqrt(rowSums((t(t(el) - ctr))^2))
# Chunk 122
area_a_small <- pi*min(dist2center)*max(dist2center)
area_a_small
# Chunk 123
area_i_large = ggplot(formants_i_large,
aes(y = F1,
x = F2)) +
geom_point() +
stat_ellipse(segments = 201) # Default is 51. We use a finer grid for more accurate area.
# Chunk 124
pb = ggplot_build(area_i_large)
el = pb$data[[2]][c("x", "y")]
# Chunk 125
ctr = MASS::cov.trob(el)$center  # Per @Roland's comment
# Chunk 126
dist2center <- sqrt(rowSums((t(t(el) - ctr))^2))
# Chunk 127
area_i_large <- pi*min(dist2center)*max(dist2center)
area_i_large
# Chunk 128
area_i_small = ggplot(formants_i_small,
aes(y = F1,
x = F2)) +
geom_point() +
stat_ellipse(segments = 201) # Default is 51. We use a finer grid for more accurate area.
# Chunk 129
pb = ggplot_build(area_i_small)
el = pb$data[[2]][c("x", "y")]
# Chunk 130
ctr = MASS::cov.trob(el)$center  # Per @Roland's comment
# Chunk 131
dist2center <- sqrt(rowSums((t(t(el) - ctr))^2))
# Chunk 132
area_i_small <- pi*min(dist2center)*max(dist2center)
area_i_small
# Chunk 133
areas <- tribble(
~size_large, ~size_small,
area_a_large, area_a_small,
area_i_large, area_i_small)
# Chunk 134
t.test(areas$size_large, areas$size_small, paired = T)
# Chunk 135
rm(area_a_large,area_a_small,area_i_large,area_i_small,ctr,dist2center,pb,el)
# Chunk 136
can <- can %>%
mutate(f_disp = ((F2 - F1) + (F3 - F2)) / 2)
# Chunk 137
can %>%
group_by(speaker, vowel) %>%
summarize(mean_f_disp = mean(f_disp, na.rm = TRUE)) %>%
ungroup() %>%
print(n = Inf)
# Chunk 138
cor.test(can$lip_dist, can$F1)
# Chunk 139
ggplot(can,
aes(x = lip_dist,
y = F1)) +
geom_point(alpha = 0.2) +
geom_smooth(size = 1,
method = lm,
se = F)
# Chunk 140
cor.test(can$lip_dist, can$f_disp)
# Chunk 141
ggplot(can,
aes(x = lip_dist,
y = f_disp)) +
geom_point(alpha = 0.2) +
geom_smooth(size = 1,
method = lm,
se = F)
# Chunk 142
# Histogram for lip_dist
ggplot(can, aes(x = lip_dist)) +
geom_histogram(bins = 30, fill = "blue", color = "black") +
labs(title = "Distribution of lip_dist", x = "lip_dist", y = "Frequency") +
theme_minimal()
# looks kind of normal
# Histogram for f_disp
ggplot(can, aes(x = f_disp)) +
geom_histogram(bins = 30, fill = "blue", color = "black") +
labs(title = "Distribution of f_disp", x = "f_disp", y = "Frequency") +
theme_minimal()
# this is skewed, I would opt for lognormal
# Descriptive Statistics
summary(can$lip_dist)
summary(can$f_disp)
# Chunk 143
# In intercept is 1000
log(4)
# If we set the prior to normal(0,1), what would be the boundaries
exp(log(4)-.5); exp(log(4)+.5)
# If we set the prior to normal(0,2), what would be the boundaries
exp(log(4)-1); exp(log(4)+1)
# If we set the prior to normal(0,3), what would be the boundaries
exp(log(4)-1.5); exp(log(4)+1.5)
# Chunk 144
get_prior(formula = lip_dist ~ 1 + vowel_s + can_size_s + head_pos + h_pos + v_pos + height + # head_pos and v_pos will be separated
(1 + vowel_s + can_size_s + head_pos + h_pos + v_pos || speaker),
data = can,
family = lognormal())
# Chunk 145
priors_maxH2_lip <- c(
prior('normal(0, 3)', class = 'Intercept'),
prior('normal(0, 1)', class = b)
)
# Chunk 146
mdl_maxH2_lip_headPos <- brm(lip_dist ~
1 + vowel_s + can_size_s +
head_pos + h_pos + height +
(1 + vowel_s + can_size_s +
head_pos + h_pos || speaker),
data = can,
prior = priors_maxH2_lip,
family = lognormal(),
#backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 8000,
warmup = 4000,
seed = 998,
save_pars = save_pars(all = TRUE),
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_maxH2_lip_headPos.rds"))
# if we need to compress the model more
#saveRDS(mdl_maxH2_lip_headPos, file = paste0(models, "mdl_maxH2_lip_headPos.rds"), compress = "xz")
mdl_maxH2_lip_headPos <- readRDS(paste0(models, "mdl_maxH2_lip_headPos.rds"))
beepr::beep()
# Chunk 147
summary(mdl_maxH2_lip_headPos)
# Chunk 148
plot(mdl_maxH2_lip_headPos)
conditional_effects(mdl_maxH2_lip_headPos, sample_prior = "only")
# Chunk 151
# run loo mdl
if (file.exists(paste0(models, "mdl_maxH2_lip_headPos_loo.rds"))) {
mdl_maxH2_lip_headPos_loo <- readRDS(paste0(models, "mdl_maxH2_lip_headPos_loo.rds"))
} else {
mdl_maxH2_lip_headPos_loo <- loo(mdl_maxH2_lip_headPos, moment_match = TRUE)
saveRDS(mdl_maxH2_lip_headPos_loo, paste0(models, "mdl_maxH2_lip_headPos_loo.rds"))
}
# Chunk 152
mdl_maxH2_lip_headPos_loo
# Chunk 153
if (file.exists(paste0(models, "mdl_maxH2_lip_headPos_reloo.rds"))) {
mdl_maxH2_lip_headPos_reloo <- readRDS(paste0(models, "mdl_maxH2_lip_headPos_reloo.rds"))
} else {
mdl_maxH2_lip_headPos_reloo <- reloo(mdl_maxH2_lip_headPos_loo, mdl_maxH2_lip_headPos, chains = 1)
saveRDS(mdl_maxH2_lip_headPos_reloo, paste0(models, "mdl_maxH2_lip_headPos_reloo.rds"))
}
mdl_maxH2_lip_headPos_reloo
# Chunk 154
mdl_maxH2_lip_vPos <- brm(lip_dist ~ 1 + vowel_s + can_size_s +
h_pos + v_pos + height +
(1 + vowel_s + can_size_s +
h_pos + v_pos || speaker),
data = can,
prior = priors_maxH2_lip,
family = lognormal(),
#backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 8000,
warmup = 4000,
seed = 998,
save_pars = save_pars(all = TRUE),
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_maxH2_lip_vPos.rds"))
# if we need to compress the model more
#saveRDS(mdl_maxH2_lip_vPos, file = paste0(models, "mdl_maxH2_lip_vPos.rds"), compress = "xz")
mdl_maxH2_lip_vPos <- readRDS(paste0(models, "mdl_maxH2_lip_vPos.rds"))
beepr::beep()
# Chunk 155
summary(mdl_maxH2_lip_vPos)
# Chunk 156
plot(mdl_maxH2_lip_vPos)
conditional_effects(mdl_maxH2_lip_vPos, sample_prior = "only")
# Chunk 159
# run loo mdl
if (file.exists(paste0(models, "mdl_maxH2_lip_vPos_loo.rds"))) {
mdl_maxH2_lip_vPos_loo <- readRDS(paste0(models, "mdl_maxH2_lip_vPos_loo.rds"))
} else {
mdl_maxH2_lip_vPos_loo <- loo(mdl_maxH2_lip_vPos, moment_match = TRUE)
saveRDS(mdl_maxH2_lip_vPos_loo, paste0(models, "mdl_maxH2_lip_vPos_loo.rds"))
}
mdl_maxH2_lip_vPos_loo
# In intercept is 1000
log(1000)
# If we set the prior to normal(0,5), what would be the boundaries
exp(log(1000)-2.5); exp(log(1000)+2.5)
# If we set the prior to normal(0,4), what would be the boundaries
exp(log(1000)-2); exp(log(1000)+2)
# If we set the prior to normal(0,3), what would be the boundaries
exp(log(1000)-1.5); exp(log(1000)+1.5)
get_prior(formula = f_disp ~ 1 + vowel_s + can_size_s + head_pos + h_pos + v_pos + height + # head_pos and v_pos will be separated
(1 + vowel_s + can_size_s + head_pos + h_pos + v_pos || speaker),
data = can,
family = lognormal())
priors_maxH2_form <- c(
prior('normal(0, 4)', class = 'Intercept'),
prior('normal(0, 1)', class = b)
)
mdl_maxH2_form_headPos <- brm(f_disp ~
1 + vowel_s + can_size_s +
head_pos + h_pos + height +
(1 + vowel_s + can_size_s +
head_pos + h_pos || speaker),
data = can,
prior = priors_maxH2_form,
family = lognormal(),
backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 8000,
warmup = 4000,
seed = 998,
save_pars = save_pars(all = TRUE),
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_maxH2_form_headPos.rds"))
mdl_maxH2_form_headPos <- brm(f_disp ~
1 + vowel_s + can_size_s +
head_pos + h_pos + height +
(1 + vowel_s + can_size_s +
head_pos + h_pos || speaker),
data = can,
prior = priors_maxH2_form,
family = lognormal(),
#backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 8000,
warmup = 4000,
seed = 998,
save_pars = save_pars(all = TRUE),
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_maxH2_form_headPos.rds"))
# if we need to compress the model more
#saveRDS(mdl_maxH2_form_headPos, file = paste0(models, "mdl_maxH2_form_headPos.rds"), compress = "xz")
mdl_maxH2_form_headPos <- readRDS(paste0(models, "mdl_maxH2_form_headPos.rds"))
beepr::beep()
summary(mdl_maxH2_form_headPos)
pp_check(mdl_maxH2_form_headPos, ndraws = 100)
# run loo mdl
if (file.exists(paste0(models, "mdl_maxH2_form_headPos_loo.rds"))) {
mdl_maxH2_form_headPos_loo <- readRDS(paste0(models, "mdl_maxH2_form_headPos_loo.rds"))
} else {
mdl_maxH2_form_headPos_loo <- loo(mdl_maxH2_form_headPos, moment_match = TRUE)
saveRDS(mdl_maxH2_form_headPos_loo, paste0(models, "mdl_maxH2_form_headPos_loo.rds"))
}
mdl_maxH2_form_headPos_loo
if (file.exists(paste0(models, "mdl_maxH2_form_headPos_reloo.rds"))) {
mdl_maxH2_form_headPos_reloo <- readRDS(paste0(models, "mdl_maxH2_form_headPos_reloo.rds"))
} else {
mdl_maxH2_form_headPos_reloo <- reloo(mdl_maxH2_form_headPos_loo, mdl_maxH2_form_headPos, chains = 1)
saveRDS(mdl_maxH2_form_headPos_reloo, paste0(models, "mdl_maxH2_form_headPos_reloo.rds"))
}
mdl_maxH2_form_headPos_reloo
mdl_maxH2_form_vPos <- brm(f_disp ~ 1 + vowel_s + can_size_s +
h_pos + v_pos + height +
(1 + vowel_s + can_size_s +
h_pos + v_pos || speaker),
data = can,
prior = priors_maxH2_form,
family = lognormal(),
#backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 8000,
warmup = 4000,
seed = 998,
save_pars = save_pars(all = TRUE),
control = list(max_treedepth = 13,
adapt_delta = 0.99),
file = paste0(models, "mdl_maxH2_form_vPos.rds"))
# if we need to compress the model more
#saveRDS(mdl_maxH2_form_vPos, file = paste0(models, "mdl_maxH2_form_vPos.rds"), compress = "xz")
mdl_maxH2_form_vPos <- readRDS(paste0(models, "mdl_maxH2_form_vPos.rds"))
beepr::beep()
summary(mdl_maxH2_form_vPos)
pp_check(mdl_maxH2_form_vPos, ndraws = 100)
# run loo mdl
if (file.exists(paste0(models, "mdl_maxH2_form_vPos_loo.rds"))) {
mdl_maxH2_form_vPos_loo <- readRDS(paste0(models, "mdl_maxH2_form_vPos_loo.rds"))
} else {
mdl_maxH2_form_vPos_loo <- loo(mdl_maxH2_form_vPos, moment_match = TRUE)
saveRDS(mdl_maxH2_form_vPos_loo, paste0(models, "mdl_maxH2_form_vPos_loo.rds"))
}
mdl_maxH2_form_vPos_loo
if (file.exists(paste0(models, "mdl_maxH2_form_vPos_reloo.rds"))) {
mdl_maxH2_form_vPos_reloo <- readRDS(paste0(models, "mdl_maxH2_form_vPos_reloo.rds"))
} else {
mdl_maxH2_form_vPos_reloo <- reloo(mdl_maxH2_form_vPos_loo, mdl_maxH2_form_vPos, chains = 1)
saveRDS(mdl_maxH2_form_vPos_reloo, paste0(models, "mdl_maxH2_form_vPos_reloo.rds"))
}
mdl_maxH2_form_vPos_reloo
p_hPos_mover
